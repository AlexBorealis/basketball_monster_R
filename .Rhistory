distinct(name_player, .keep_all = T) %>%
.[, .(time_observ,
name_player,
status_player,
position_player,
team)] %>%
.[order(team)] %>%
.[order(-time_observ)]
read.table("bots.txt", header = T)
read.table("bots.txt", header = T)
read.table("bots.txt", header = T)[name == "basketball_monster_table", value]
read.table("bots.txt", header = T)["name" == "basketball_monster_table", "value"]
data.table(read.table("bots.txt", header = T))[name == "basketball_monster_table", value]
data.table(read.table("bots.txt", header = T))[name == "basketball_monster_table", value]
source("D:/R/Work/My_scripts/basketball_monster/basketball_monster/send_table.R")
source("D:/R/Work/My_scripts/basketball_monster/basketball_monster/send_table.R")
data.table(read.table("bots.txt", header = T))[name == "basketball_monster", value]
source("D:/R/Work/My_scripts/basketball_monster/basketball_monster/send_table.R")
getwd()
list.files(getwd(), pattern = ".RData"))
paste0(getwd(), list.files(getwd(), pattern = ".RData"))
paste0(getwd(), list.files(getwd(), "/", pattern = ".RData"))
paste0(getwd(), list.files(getwd(), "/", pattern = ".RData")))
list.files(getwd(), "/", pattern = ".RData")
paste0(getwd(), "/", list.files(getwd(), pattern = ".RData")))
paste0(getwd(), "/", list.files(getwd(), pattern = ".RData"))
"D:/R/Work/My_scripts/basketball_monster/basketball_monster/basketball_monster.RData"
paste0(getwd(), "/", list.files(getwd(), pattern = ".RData"))
## Load packages
source(paste0(getwd(), "/need_pckgs.R"),
local = T)
read.table("db_vars.txt", header = T)
read.table("db_vars.txt", header = T)
data.table(read.table("url_vars.txt", header = T))
data.table(read.table("url_vars.txt", header = T))
data.table(read.table("url_vars.txt", header = T))
for_url <- data.table(read.table("url_vars.txt", header = T))
for_url$value
"https://basketballmonster.com/playernews.aspx"
for_url[name == "url", value]
data.table(read.table("tg_vars.txt", header = T))
for_db <- data.table(read.table("db_vars.txt", header = T))
for_tg <- data.table(read.table("tg_vars.txt", header = T))
for_tg
for_tg[name == "chat_id", value]
for_db
for_db[name == "user", value]
for_db[name == "password", value]
for_db[name == "password", value] |> as.null()
pool <- dbPool(RPostgreSQL::PostgreSQL(),
user = for_db[name == "user", value],
password = for_db[name == "password", value],
dbname = for_db[name == "dbname", value],
host = for_db[name == "host", value],
maxSize = 1,
idleTimeout = 1,
validationInterval = 0) # Connect to PostgreSQL
data.table(dbGetQuery(pool, str_glue("select * from alerts where date_observ = '{Sys.Date()}'")))[order(-time_observ)] %>%
mutate(status_player = gsub(x = status_player, pattern = "high level - ", replacement = "")) %>%
distinct(status_player, .keep_all = T) %>%
distinct(name_player, .keep_all = T) %>%
.[, .(name_player,
status_player,
position_player,
team)] %>%
.[order(team)]
poolClose(pool)
for_db <- data.table(read.table("db_vars.txt", header = T))
for_db <- data.table(read.table("db_vars.txt", header = T))
data.table(read.table("db_tables.txt", header = T))
db_tables <- data.table(read.table("db_tables.txt", header = T))
## Load workspace
load(paste0(getwd(), "/", list.files(getwd(), pattern = ".RData")))
ls()
source("D:/R/Work/My_scripts/basketball_monster/basketball_monster/send_table.R")
exists("for_bot")
source("D:/R/Work/My_scripts/basketball_monster/basketball_monster/send_table.R")
source("D:/R/Work/My_scripts/basketball_monster/basketball_monster/send_table.R")
renv::snapshot(confirm = FALSE)
source("D:/R/Work/My_scripts/basketball_monster/basketball_monster/main.R")
## Setting directory
setwd(getwd())
## Load workspace
load(paste0(getwd(), "/", list.files(getwd(), pattern = ".RData")))
## Load packages
source(paste0(getwd(), "/need_pckgs.R"),
local = T)
## Load engine
source(paste0(getwd(), "/engine.R"),
local = T)
## Reading needed variables (for bots, for DB, for telegram and for site)
token <- data.table(read.table("bots_vars.txt", header = T))[name == "basketball_monster", value]
for_db <- data.table(read.table("db_vars.txt", header = T))
for_url <- data.table(read.table("url_vars.txt", header = T))
for_tg <- data.table(read.table("tg_vars.txt", header = T))
db_tables <- data.table(read.table("db_tables.txt", header = T))
## Creation class Bot
bot <- Bot(token = token)
updates <- bot$getUpdates()
# Read main html
main_html <- read_html(for_url[name == "url", value]) |>
html_elements(xpath = "//*[@class='q-su-holder']")
# Getting xml length
length_list_player <- main_html |>
xml_length()
View(for_db)
for_db[name == "password", value]
pool <- dbPool(RPostgreSQL::PostgreSQL(),
user = for_db[name == "user", value],
password = for_db[name == "password", value],
dbname = for_db[name == "dbname", value],
host = for_db[name == "host", value],
maxSize = 1,
idleTimeout = 1,
validationInterval = 0) # Connect to PostgreSQL
dbWriteTable(pool, value = for_db, name = "for_db")
poolClose(pool)
pool <- dbPool(RPostgreSQL::PostgreSQL(),
user = for_db[name == "user", value],
password = for_db[name == "password", value],
dbname = for_db[name == "dbname", value],
host = for_db[name == "host", value],
maxSize = 1,
idleTimeout = 1,
validationInterval = 0) # Connect to PostgreSQL
dbListTables(pool)
dbReadTable(pool, "for_db")
dbRemoveTable(pool, "for_db")
poolClose(pool)
identical(for_bot[status_player %like% "high level"],
map_dfr(1:length_list_player, \(j) {
data.table(name_player = name_player(j),
status_player = status_player(j),
position_player = position_player(j),
team = team(j))
})[status_player %like% "high level"])
map_dfr(1:length_list_player, \(j) {
data.table(name_player = name_player(j),
status_player = status_player(j),
position_player = position_player(j),
team = team(j))
})[status_player %like% "high level"]
new_player <- map_dfr(1:length_list_player, \(j) {
data.table(name_player = name_player(j),
status_player = status_player(j),
position_player = position_player(j),
team = team(j))
})[status_player %like% "high level"]
data.table(date_observ = strftime(Sys.time(), format = "%Y-%m-%d"),
time_observ = strftime(Sys.time(), format = "%H:%M:%S"),
anti_join(new_player,
for_bot[status_player %like% "high level"],
by = c("name_player", "status_player", "position_player", "team")))[!is.na(status_player)]
source("D:/R/Work/My_scripts/basketball_monster/basketball_monster/main.R")
## Setting directory
setwd(getwd())
## Load workspace
load(paste0(getwd(), "/", list.files(getwd(), pattern = ".RData")))
## Load packages
source(paste0(getwd(), "/need_pckgs.R"),
local = T)
## Load engine
source(paste0(getwd(), "/engine.R"),
local = T)
## Reading needed variables (for bots, for DB, for telegram and for site)
token <- data.table(read.table("bots_vars.txt", header = T))[name == "basketball_monster", value]
for_db <- data.table(read.table("db_vars.txt", header = T))
for_url <- data.table(read.table("url_vars.txt", header = T))
for_tg <- data.table(read.table("tg_vars.txt", header = T))
db_tables <- data.table(read.table("db_tables.txt", header = T))
## Creation class Bot
bot <- Bot(token = token)
updates <- bot$getUpdates()
# Read main html
main_html <- read_html(for_url[name == "url", value]) |>
html_elements(xpath = "//*[@class='q-su-holder']")
# Getting xml length
length_list_player <- main_html |>
xml_length()
# Main process
# 1) Checking if an object 'for_bot' exists
# 2) Checking if an identical object 'for_bot' and last changes fro site
# 3) If last changes and 'for_bot' is not identical then send message to TG and in DB
if (exists("for_bot")) {
if (identical(for_bot[status_player %like% "high level"],
map_dfr(1:length_list_player, \(j) {
data.table(name_player = name_player(j),
status_player = status_player(j),
position_player = position_player(j),
team = team(j))
})[status_player %like% "high level"])) {
NULL
} else {
new_player <- map_dfr(1:length_list_player, \(j) {
data.table(name_player = name_player(j),
status_player = status_player(j),
position_player = position_player(j),
team = team(j))
})[status_player %like% "high level"]
DT <- data.table(date_observ = strftime(Sys.time(), format = "%Y-%m-%d"),
time_observ = strftime(Sys.time(), format = "%H:%M:%S"),
anti_join(new_player,
for_bot[status_player %like% "high level"],
by = c("name_player", "status_player", "position_player", "team")))[!is.na(status_player)]
if (nrow(DT) > 0) {
lst <- map(1:nrow(DT), \(i) {
bot$sendMessage(chat_id = for_tg[name == "chat_id", value],
text = str_glue("{new_player$name_player[i]} {new_player$position_player[i]} ({new_player$team[i]})
{new_player$status_player[i]}") |> gsub(pattern = "high level - ", replacement = ""))
})
pool <- dbPool(RPostgreSQL::PostgreSQL(),
user = for_db[name == "user", value],
password = for_db[name == "password", value],
dbname = for_db[name == "dbname", value],
host = for_db[name == "host", value],
maxSize = 1,
idleTimeout = 1,
validationInterval = 0) # Connect to PostgreSQL
dbWriteTable(pool,
value = DT,
name = db_tables[1],
append = T,
row.names = F)
poolClose(pool)
} else {
NULL
}
}
} else {
for_bot <- map_dfr(1:length_list_player, \(j) {
data.table(name_player = name_player(j),
status_player = status_player(j),
position_player = position_player(j),
team = team(j))
})
}
db_tables[1]
db_tables$table_name[1]
Sys.Date()
## Load packages
source(paste0(getwd(), "/need_pckgs.R"),
local = T)
## Load workspace
load(paste0(getwd(), "/", list.files(getwd(), pattern = ".RData")))
for_bot
for_bot[status_player %like% "high level"]
for_bot[status_player %like% "high level"] |> distinct(pick(status_player, name_player), .keep_all = T)
for_bot[status_player %like% "high level"] |> distinct(pick(status_player), .keep_all = T)
for_bot[status_player %like% "high level"] |> distinct(pick(name_player, status_player), .keep_all = T)
for_bot[status_player %like% "high level"] |> distinct(pick(name_player), .keep_all = T)
for_bot[status_player %like% "high level"] |> distinct(pick(status_player), .keep_all = T)
for_bot[status_player %like% "high level"] |> distinct(status_player, .keep_all = T)
for_bot[status_player %like% "high level"] |> distinct(status_player, .keep_all = T) |> distinct(name_player, .keep_all = T)
install.packages("retry")
library(retry, warn.conflicts = F)
?retry
read_html(for_url[name == "url", value]) |>
html_elements(xpath = "//*[@class='q-su-holder']")
## Load packages
source(paste0(getwd(), "/need_pckgs.R"),
local = T)
read_html(for_url[name == "url", value]) |>
html_elements(xpath = "//*[@class='q-su-holder']")
for_url <- data.table(read.table("url_vars.txt", header = T))
read_html(for_url[name == "url", value]) |>
html_elements(xpath = "//*[@class='q-su-holder']")
read_html(for_url[name == "url", value]) |>
html_elements(xpath = "//*[@class='q-su-holder']") |> class()
retry({
main_html <- read_html(for_url[name == "url", value]) |>
html_elements(xpath = "//*[@class='q-su-holder']")
}, until = ~ class(main_html) == "xml_nodeset")
class({
read_html(for_url[name == "url", value]) |>
html_elements(xpath = "//*[@class='q-su-holder']")
}) == "xml_nodeset"
# Read main html
retry({
main_html <- read_html(for_url[name == "url", value]) |>
html_elements(xpath = "//*[@class='q-su-holder']")
}, until = ~ class({
read_html(for_url[name == "url", value]) |>
html_elements(xpath = "//*[@class='q-su-holder']")
}) == "xml_nodeset", timeout = 5)
# Read main html
retry({
main_html <- read_html(for_url[name == "url", value]) |>
html_elements(xpath = "//*[@class='q-su-holder']")
}, until = ~ class({
read_html(for_url[name == "url", value]) |>
html_elements(xpath = "//*[@class='q-su-holder']")
}) == "xml_nodeset", timeout = 2)
# Read main html
retry({
main_html <- read_html(for_url[name == "url", value]) |>
html_elements(xpath = "//*[@class='q-su-holder']")
}, until = ~ class(.) == "xml_nodeset", timeout = 2)
renv::snapshot(confirm = FALSE)
rlang::cnd_signal(cnd)
## Load packages
source(paste0(getwd(), "/need_pckgs.R"),
local = T)
## Load workspace
load(paste0(getwd(), "/", list.files(getwd(), pattern = ".RData")))
## Load packages
source(paste0(getwd(), "/need_pckgs.R"),
local = T)
## Load engine
source(paste0(getwd(), "/engine.R"),
local = T)
## Reading needed variables (for bots, for DB, for telegram and for site)
token <- data.table(read.table("bots_vars.txt", header = T))[name == "basketball_monster", value]
for_db <- data.table(read.table("db_vars.txt", header = T))
for_url <- data.table(read.table("url_vars.txt", header = T))
for_tg <- data.table(read.table("tg_vars.txt", header = T))
db_tables <- data.table(read.table("db_tables.txt", header = T))
## Creation class Bot
bot <- Bot(token = token)
# Read main html
main_html <- read_html(for_url[name == "url", value],
handle = curl::new_handle("useragent" = "Mozilla/5.0"),
options = c("RECOVER", "PEDANTIC"),
verbose = T) |>
html_elements(xpath = "//*[@class='q-su-holder']")
# Getting xml length
length_list_player <- main_html |>
xml_length()
new_player <- map_dfr(1:length_list_player, \(j) {
data.table(name_player = name_player(j),
status_player = status_player(j),
position_player = position_player(j),
team = team(j))
})[status_player %like% "high level"] |>
distinct(status_player, .keep_all = T)
identical(for_bot[status_player %like% "high level"], new_player)
# Reading existing table from DB
pool <- dbPool(RPostgreSQL::PostgreSQL(),
user = for_db[name == "user", value],
password = for_db[name == "password", value],
dbname = for_db[name == "dbname", value],
host = for_db[name == "host", value],
maxSize = 1,
idleTimeout = 1,
validationInterval = 0)
dbRemoveTable(pool, "alerts")
poolClose(pool)
## Load workspace
load(paste0(getwd(), "/", list.files(getwd(), pattern = ".RData")))
## Load packages
source(paste0(getwd(), "/need_pckgs.R"),
local = T)
## Load engine
source(paste0(getwd(), "/engine.R"),
local = T)
## Reading needed variables (for bots, for DB, for telegram and for site)
token <- data.table(read.table("bots_vars.txt", header = T))[name == "basketball_monster", value]
for_db <- data.table(read.table("db_vars.txt", header = T))
for_url <- data.table(read.table("url_vars.txt", header = T))
for_tg <- data.table(read.table("tg_vars.txt", header = T))
db_tables <- data.table(read.table("db_tables.txt", header = T))
## Creation class Bot
bot <- Bot(token = token)
# Read main html
main_html <- read_html(for_url[name == "url", value],
handle = curl::new_handle("useragent" = "Mozilla/5.0"),
options = c("RECOVER", "PEDANTIC"),
verbose = T) |>
html_elements(xpath = "//*[@class='q-su-holder']")
# Getting xml length
length_list_player <- main_html |>
xml_length()
new_player <- map_dfr(1:length_list_player, \(j) {
data.table(name_player = name_player(j),
status_player = status_player(j),
position_player = position_player(j),
team = team(j))
})[status_player %like% "high level"] |>
distinct(status_player, name_player, .keep_all = T)
all.equal(for_bot[status_player %like% "high level"], new_player)
all.equal(for_bot[status_player %like% "high level"], new_player[1])
for_bot[status_player %like% "high level"]
new_player
data.table(date_observ = strftime(Sys.time(), format = "%Y-%m-%d"),
time_observ = strftime(Sys.time(), format = "%H:%M:%S"),
anti_join(new_player,
for_bot[status_player %like% "high level"],
by = c("name_player", "status_player", "position_player", "team")))[!is.na(status_player)] |>
distinct(status_player, name_player, .keep_all = T)
data.table(date_observ = strftime(Sys.time(), format = "%Y-%m-%d"),
time_observ = strftime(Sys.time(), format = "%H:%M:%S"),
anti_join(new_player[1],
for_bot[status_player %like% "high level"],
by = c("name_player", "status_player", "position_player", "team")))[!is.na(status_player)] |>
distinct(status_player, name_player, .keep_all = T)
new_player
for_bot[status_player %like% "high level"]
for_bot[status_player %like% "high level"][1]
data.table(date_observ = strftime(Sys.time(), format = "%Y-%m-%d"),
time_observ = strftime(Sys.time(), format = "%H:%M:%S"),
anti_join(new_player,
for_bot[status_player %like% "high level"][1],
by = c("name_player", "status_player", "position_player", "team")))
data.table(date_observ = strftime(Sys.time(), format = "%Y-%m-%d"),
time_observ = strftime(Sys.time(), format = "%H:%M:%S"),
anti_join(new_player,
for_bot[status_player %like% "high level"][1],
by = c("name_player", "status_player", "position_player", "team")))[!is.na(status_player)] |>
distinct(status_player, name_player, .keep_all = T)
data.table(date_observ = strftime(Sys.time(), format = "%Y-%m-%d"),
time_observ = strftime(Sys.time(), format = "%H:%M:%S"),
anti_join(new_player[1],
for_bot[status_player %like% "high level"],
by = c("name_player", "status_player", "position_player", "team")))
new_player
for_bot[status_player %like% "high level"][1]
data.table(date_observ = strftime(Sys.time(), format = "%Y-%m-%d"),
time_observ = strftime(Sys.time(), format = "%H:%M:%S"),
anti_join(new_player,
for_bot[status_player %like% "high level"][1],
by = c("name_player", "status_player", "position_player", "team")))
map_dfr(1:length_list_player, \(j) {
data.table(name_player = name_player(j),
status_player = status_player(j),
position_player = position_player(j),
team = team(j)) |>
distinct(status_player, name_player, .keep_all = T)
})
## Setting directory
setwd(getwd())
## Load workspace
load(paste0(getwd(), "/", list.files(getwd(), pattern = ".RData")))
## Load packages
source(paste0(getwd(), "/need_pckgs.R"), local = T)
## Load engine
source(paste0(getwd(), "/engine.R"), local = T)
## Load packages
source(paste0(getwd(), "/need_pckgs.R"), local = T)
for_db <- data.table(read.table("db_vars.txt", header = T))
# Reading existing table from DB
pool <- dbPool(RPostgreSQL::PostgreSQL(),
user = for_db[name == "user", value],
password = for_db[name == "password", value],
dbname = for_db[name == "dbname", value],
host = for_db[name == "host", value],
maxSize = 1,
idleTimeout = 1,
validationInterval = 0)
data.table(dbGetQuery(pool,
str_glue("select * from alerts where date_observ = '{Sys.Date() - 1}'")))[order(-time_observ)] %>%
mutate(status_player = gsub(x = status_player, pattern = "high level - ", replacement = ""))
data.table(dbGetQuery(pool,
str_glue("select * from alerts where date_observ = '{Sys.Date() - 1}'")))[order(-time_observ)] %>%
mutate(status_player = gsub(x = status_player, pattern = "high level - ", replacement = "")) %>%
distinct(status_player, name_player, .keep_all = T)
data.table(dbGetQuery(pool,
str_glue("select * from alerts where date_observ = '{Sys.Date() - 1}'")))[order(-time_observ)] %>%
mutate(status_player = gsub(x = status_player, pattern = "high level - ", replacement = "")) %>%
distinct(status_player, name_player, .keep_all = T) %>%
.[, .(name_player,
status_player,
position_player,
team)]
data.table(dbGetQuery(pool,
str_glue("select * from alerts where date_observ = '{Sys.Date() - 1}'")))[order(-time_observ)] %>%
mutate(status_player = gsub(x = status_player, pattern = "high level - ", replacement = "")) %>%
distinct(status_player, .keep_all = T) %>%
distinct(name_player, .keep_all = T) %>%
.[, .(name_player,
status_player,
position_player,
team)]
data.table(dbGetQuery(pool,
str_glue("select * from alerts where date_observ = '{Sys.Date() - 1}'")))[order(-time_observ)] %>%
mutate(status_player = gsub(x = status_player, pattern = "high level - ", replacement = ""))
data.table(dbGetQuery(pool,
str_glue("select * from alerts where date_observ = '{Sys.Date() - 1}'")))[order(-time_observ)] %>%
mutate(status_player = gsub(x = status_player, pattern = "high level - ", replacement = "")) %>%
distinct(status_player, .keep_all = T) %>%
distinct(name_player, .keep_all = T) %>%
.[, .(name_player,
status_player,
position_player,
team)]
for_url <- data.table(read.table("url_vars.txt", header = T))
# Read main html
main_html <- read_html(for_url[name == "url", value],
handle = curl::new_handle("useragent" = "Mozilla/5.0"),
options = c("RECOVER", "PEDANTIC"),
verbose = T) |>
html_elements(xpath = "//*[@class='q-su-holder']")
# Getting xml length
length_list_player <- main_html |>
xml_length()
map_dfr(1:length_list_player, \(j) {
data.table(name_player = name_player(j),
status_player = status_player(j),
position_player = position_player(j),
team = team(j))
})[status_player %like% "high level"]
## Load engine
source(paste0(getwd(), "/engine.R"), local = T)
map_dfr(1:length_list_player, \(j) {
data.table(name_player = name_player(j),
status_player = status_player(j),
position_player = position_player(j),
team = team(j))
})[status_player %like% "high level"]
poolClose(pool)
renv::snapshot(confirm = FALSE)
renv::snapshot(confirm = FALSE)
.libPaths()
renv::snapshot(confirm = FALSE)
